/*
8-6 예제 설명
Derived클래스가 base를 private상속 함에 따라 setA(), showA()멤버는
private 속성으로 변경되어 Derived에 상속된다.
1. 정상컴파일 setA()는 base클래스의 protected멤버이기 때문에
	파생 클래스 Derived에 접근허용
2. 정상컴파일 showA()는 base클래스의 public멤버이기 때문에
	파생 클래스 Derived에 접근허용
3. 컴파일오류 setA()는 private 속성으로 변경되어 Derived클래스에 상속되기 때문에
	GrandDerived에게 접근 불가
4. 컴파일오류 showA()는 private 속성으로 변경되어 Derived클래스에 상속되기 때문에
	GrandDerived에게 접근 불가
5. 정상컴파일 setB()는 Derived클래스의 protected멤버이기 때문에
	파생 클래스 GRandDerived에게 접근허용
*/

//----------9장 가산함수와 추상클래스----------
/*
파생 클래스에서 기본클래스와 동일한 형식의 함수를 재정의 하는 경우,
기본 클래스에 대한 포인터로는 기본 클래스의 함수를 호출하고,
파생 클래스의 포인터로는 파생클래스에 작정된 함수를 호출한다.
이러한 호출 관계는 컴파일시에 결정된다(정적바인딩)

<참고> 범위 지정 연산자로 Base멤버 접근 가능
범위 지정 연산자(::)를 사용하면 기본클래스의 멤버함수와 파생클래스에
재정의된 함수를 구분하여 호출할 수 있따.
다음과 같이 pDer을 이용하면 된다.
pDer->f();
pDer->Base::f();
*/


/*
가상함수와 오버라이딩
오버라이딩(overriding) 개념 : 파생클래스에서 기본클래스에서 작성된
가상함수를 재작성하여, 기본 클래스에 작성된 가상함수를 무력화 시키고,
객체의 주인 노릇을 하는것.
매우 중요한 것으로, 기본 클래스의 포인터를 이용하든, 파생클래스의 포인터를
이용하든 가장함수를 호출하면, 파생클래스에 오버라이딩된 함수가 항상 실행된다.

가상함수(virtual function)란 : 
	- virtual 키워드로 선언된 멤버함수이다.
	- virtual은 컴파일러에게 자신에 대한 호출 바인딩을 실행 시간까지
	  미루도록 지시하는 키워드이다.
	- 기본클래스나 파생클래스 어디에나 선언될 수 있다.
*/


//가상함수를 선언하는 사례
/*
class Base{
public:
	virtual void f(); //f()는 가상함수
};
*/

/*
함수 오버라이딩(function overriding)이란 : 
파생클래스에서 기본 클래스의 가상함수를 재정의하는 것이다.(overriding)

<참고>
오버라이딩은 멤버함수에만 적용되므로 변수 오버라이딩이라는 용어는 없다.

<참고> 함수 재정의와 오버라이딩
함수 재정의라는 용어를 사용할때 신중을 가해야한다.
가상함수를 재정의하는 경우와 아닌 경우에 따라 프로그램의 실행이 완전히 달라지기
때문이다. 가상함수를 재정의하는 오버라이딩의 경우 함수가 호출되는 실행시간에
동적바인딩이 일어나지만, 그렇지 않은 경우 컴파일 시간에 결정된 함수가 단순히 호출된다.
(정적바인딩). java의 경우 이런 혼란이 없다.
멤버함수가 가상이냐 아니냐로 구분되지 않으며, 함수 재정의는 곧 오버라이딩이며,
무조건 동적바인딩이 일어난다.
*/


/*
동적바인딩
1. 동적바인딩 : 오버라이딩된 함수가 무조건 호출
가상함수를 호출하는 코드를 컴파일할 때, 컴파일러는 바인딩을 실행 시간에 결정하도록
미루어둔다. 나중에 가상함수가 호출되면, 실행 중에 객체 내에 오버라이딩된 가상 함수를
동적으로 찾아 호출한다. 이 과정을 동적바인딩(dynamic binding)이라고 부른다.
오버라이딩은 파생 클래스에서 재정의한 가상함수의 호출을 보장받는 선언이다.
동적바인딩은 실행시간 바인딩 혹은 늦은 바인딩이라고도 부른다

2. 동적바인딩이 발생하는 구체적 경우
기본클래스의 객체에 대해서는 가상함수가 호출된다고 하더라도 동적바인딩은
일어나지않는다. 객체 내에 오버라이딩된 가상 함수가 없기 때문이다.
동적바인딩은 파생클래스의 객체에 대해, 기본클래스의 포인터로 가상함수가 호출될 때
일어난다.

동적바인딩이 발생하는 경우
	- 기본 클래스 내의 멤버함수가 가상함수 호출
	- 파생 클래스 내의 멤버함수가 가장함수 호출
	- main()과 같은 외부함수에서 기본클래스의 포인터로 가상함수 호출
	- 다른 클래스에서 가상함수 호출
가상함수를 호출하면, 무조건 동적바인딩을 통해 파생클래스에 오버라이딩된 가상함수가
실행된다.
*/


/*
가상소멸자
파생클래스의 객체가 기본 클래스에 대한 포인터로 delete되는 상황에서도
정상적인 소멸이 되도록 하기위해서 기본 클래스의 소멸자를 만들때
가상함수로 작성할 것을 권한다.
*/

/*
소멸자를 가상함수로 선언하면, 객체를 기본 클래스의 포인터로 소멸하든,
파생클래스의 포인터로 소멸하든 파생클래스와 기본클래스의 소멸자를 모두 실행하는
정상적은 소멸의 과정이 진행된다.
기본 클래스의 소멸자를 작성할때, 고민할 것 없이 바로 virtual로 선언하기 바란다.
*/

/*
<참고> 생성자, 소멸자, 가상함수
생성자는 가상함수가 될 수 없으며, 생성자에서 가상 함수를 호출해도
동적 바인딩이 일어나지 않는다. 그러나 소멸자는 가상함수가 될수 있으며,
가상함수로 만드는것이 바람직하다
*/

/*
-----------------------------------------------------
오버로딩 : 매개변수의 타입이나 개수가 다른함수들을 여러개 중복 작성하는 것
오버라이딩 : 함수 중복은 상속관계에서도 존재할 수 있는데, 기본 클래스의 멤버함수와
            이름은 같지만 매개변수 타입이나 개수가 다른 함수를 파생클래스에서 멤버함수로
			작성할수 있다. 기본 클래스의 가삼함수를 파생클래스에서 재작성하여
			동적바인딩을 유발시키는것
함수 재정의 : 가상함수가 아는 멤버함수를 재작성하여 정적바인딩으로 처리되는것
*/



//9-6 소멸자를 가상 함수로 선언
#include <iostream>
using namespace std;

class Base {
public:
	virtual ~Base() { cout << "~Base()" << endl; }
};
class Derived : public Base {
public:
	virtual ~Derived() { cout << "~Derived()" << endl; }
};

int main()
{
	Derived *dp = new Derived();
	Base *bp = new Derived();

	delete dp; //derived의 포인터로 소멸
	delete bp; //base의 포인터로 소멸
}